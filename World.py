#!/usr/bin/python3
"""
Code  --  https://github.com/PhilippeMorere/BasicReinforcementLearning  <- old hat @2014\n
Challenge -- https://github.com/llSourcell/q_learning_demo              <- dragonWarrior teacher/student\n
Changes/commentary -- https://github.com/Ruckusist/q_learning_demo      <- Ruckusist\n

\n::: is this the best way to do this?

(1) solution idea... Place a new block attached to the last time this was updated,
starting from the player start, every time a new high score is reached or matched
until the optimum path is found. ::: is this better/same as a known something else?
::: does this break the rules? what are the rules?

::: is the internet fictional? Its a place people read about, but no one has ever been...
    like a good riddle poorly given.

(2) Actual Soluction: Decisions made sooner to the asking are more powerful (Blink: Malcolm Gladwell)
So as the score decreases so does the influnce of the cell score update.
"""

__author__ = 'philippe'
try:
    # for Python2
    from Tkinter import Tk, Canvas
except ImportError:
    # for Python3
    from tkinter import Tk, Canvas
master = Tk()

triangle_size = 0.15
cell_score_min = -10
cell_score_max = 10
squares = 10 # this did not need to be like this...:( 
Width = 50   # pixels per square, make smaller if you want huge 100x100 map


(x, y) = (12, 15)                          # cells to be played... 10 x 10... should be random and non uniform
actions = ["up", "down", "left", "right"]  # actions=enum(u,d,l,r) i think thats how it would translate...

board = Canvas(master, width=x*Width, height=y*Width)  # master is the TKwidget, lil w is actual size, big W is pixels per square, x and y are # of squares
player_start_position = (5, 7)                         # should be random, set to mid
player = player_start_position                         # Player is the avatar, its init is set to start_position and reset everyother time somewhere else
#score = 1                                             # start with a score, i think if  the # were 0 would mean that the green and red could only be 25 units away max for a poistive outcome
score = 100  # old score*100 is more readable 
restart = False                                        # bool restart = 0
walk_reward = -0.4                                     # this is the 25 max part 25 * .04 = 1 if you started at 0 would be bad... start at 1 buys you a max 50... but a better score solution could make for better results

# should be randomly generated by % so 10% randomly shaded but adjustable # But i build a funny wall instead...
walls = [(1,1),(1,2),(1,8),(2,1),(2,2),(3,3),(4,4),(4,5),(5,6),(6,7),(6,8),(6,0),(7,9),(7,10),(7,12),(7,13),(7,14),(7,7),(7,8),(8,1)]

# should be randomly generated, blue is start position, should not be a path that works by calling your self a bunch of times 
# blue and red should not qualify for a high score.
specials = [(9, 1, "red", -1),(11,1,"red",-100),(player_start_position[0],player_start_position[1],"blue",-98), (9, 0, "green", 1)]
cell_scores = {} # this is an empty set :(


# Draw Triangles ::  
def create_triangle(i, j, action):
    if action == actions[0]:
        return board.create_polygon((i+0.5-triangle_size)*Width, (j+triangle_size)*Width,
                                    (i+0.5+triangle_size)*Width, (j+triangle_size)*Width,
                                    (i+0.5)*Width, j*Width,
                                    fill="white", width=1)
    elif action == actions[1]:
        return board.create_polygon((i+0.5-triangle_size)*Width, (j+1-triangle_size)*Width,
                                    (i+0.5+triangle_size)*Width, (j+1-triangle_size)*Width,
                                    (i+0.5)*Width, (j+1)*Width,
                                    fill="white", width=1)
    elif action == actions[2]:
        return board.create_polygon((i+triangle_size)*Width, (j+0.5-triangle_size)*Width,
                                    (i+triangle_size)*Width, (j+0.5+triangle_size)*Width,
                                    i*Width, (j+0.5)*Width,
                                    fill="white", width=1)
    elif action == actions[3]:
        return board.create_polygon((i+1-triangle_size)*Width, (j+0.5-triangle_size)*Width,
                                    (i+1-triangle_size)*Width, (j+0.5+triangle_size)*Width,
                                    (i+1)*Width, (j+0.5)*Width,
                                    fill="white", width=1)
#<endif>
# bring in colored sqares, walls, pixels per square, x,y amount of squres, with one funny sized square(avatar!)
def render_grid():
    global specials, walls, Width, x, y, player
    for i in range(x):
        for j in range(y):
            board.create_rectangle(i*Width, j*Width, (i+1)*Width, (j+1)*Width, fill="#111813", width=1)
            temp = {}
            for action in actions:
                temp[action] = create_triangle(i, j, action)
            cell_scores[(i,j)] = temp
    for (i, j, c, w) in specials:
        board.create_rectangle(i*Width, j*Width, (i+1)*Width, (j+1)*Width, fill=c, width=1)
    for (i, j) in walls:
        board.create_rectangle(i*Width, j*Width, (i+1)*Width, (j+1)*Width, fill="white", width=1)
#<endif>
render_grid() # cast spell grid

# voodoo magic...
def set_cell_score(state, action, val):
    global cell_score_min, cell_score_max, score
    if score > 75:                  test = 6; # decision influence variable
    elif score < 75 and score > 50: test = 3;
    elif score < 50 and score > 25: test = 1.5;
    else:                           test = 1;
    triangle = cell_scores[state][action]
    green_dec = int(min(255, max(0, ((val*test) - cell_score_min) * 255.0 / (cell_score_max - cell_score_min)))) #?? voodoo magic
    green = hex(green_dec)[2:]
    red = hex(255-green_dec)[2:]
    if len(red) == 1:
        red += "0"
    if len(green) == 1:
        green += "0"
    color = "#" + red + green + "11"
    board.itemconfigure(triangle, fill=color)
#<endif>

# player is the cur, cur_x,y , score, -.04 , avatar, bool startagain=false
def try_move(dx, dy): # take the amount of motion in the ocean
    global player, x, y, score, walk_reward, me, restart
    if restart == True:
        restart_game()
    new_x = player[0] + dx
    new_y = player[1] + dy
    score += walk_reward
    if score < 0:
        print("!\tran out of lives :<")
        restart = True
        return
    if (new_x >= 0) and (new_x < x) and (new_y >= 0) and (new_y < y) and not ((new_x, new_y) in walls):
        board.coords(me, new_x*Width+Width*2/squares, new_y*Width+Width*2/squares, new_x*Width+Width*8/squares, new_y*Width+Width*8/squares)
        player = (new_x, new_y)
    for (i, j, c, w) in specials: # we are treating all specials the same... we need weak/strong nodes too...
        if new_x == i and new_y == j:
            score -= walk_reward
            score += w
            restart = True
            return
#<endif>
# ACTIONS
def call_up(event): try_move(0, -1);
def call_down(event): try_move(0, 1);
def call_left(event): try_move(-1, 0);
def call_right(event): try_move(1, 0);

# AGAIN!
def restart_game():
    global player, score, me, restart
    player = player_start_position
    score = 100
    restart = False
    board.coords(me, player[0]*Width+Width*2/squares, player[1]*Width+Width*2/squares, player[0]*Width+Width*8/squares, player[1]*Width+Width*8/squares)
#<endif>
def has_restarted():
    return restart #? i dont care for this... should be something=true?
#<endif>
master.bind("<Up>", call_up)       # this all just sounds wrong doesnt it...
master.bind("<Down>", call_down)   # humiliating really.
master.bind("<Right>", call_right) # maybe its like quarterback.hike"right42", on3 
master.bind("<Left>", call_left)   # ...

# this is your square ... i made mine purple :)
me = board.create_rectangle(player[0]*Width+Width*2/squares, player[1]*Width+Width*2/squares,
                            player[0]*Width+Width*8/squares, player[1]*Width+Width*8/squares, 
                            fill="purple", width=1, tag="me")

# bored? almost done...
board.grid(row=0, column=0)

# master control valve
def start_game():
    master.mainloop()
